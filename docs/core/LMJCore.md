# LMJCore
## LMJCore系统简介
LMJCore 是一个基于 LMDB 的高性能、嵌入式、无模式（Schema-less）键值存储引擎。它并非一个传统的、直接面向应用层的数据库，而是一个专为**极致性能**和**极致灵活性**而设计的**结构化数据存储内核**。

其核心创新在于通过“**指针**”，将复杂的嵌套数据结构（如 JSON）**扁平化**存储，并在此基础上提供了原子化的对象与数组操作原语。LMJCore 本身不提供高级查询功能（如 SQL 或聚合查询），而是将这些能力委托给上层的**查询层**（如 LMJQuery 官方上层实现 -- 画饼中）来实现。这种**存储与计算分离**的设计，使得 LMJCore 可以作为一个稳定、可靠、高性能的数据基石，被多个独立的查询引擎同时使用，为实现分布式架构和水平扩展奠定了坚实的基础。

**核心定位：专注于数据的“存”、“取”、“管”，而非“查”。**

## LMJCore框架简介
#### 一、核心设计哲学

LMJDB 是一个基于 LMDB 的嵌入式数据管理框架，其核心设计哲学是：
1.  **指针**：一切数据实体（对象、数组）均通过全局唯一的字符串指针引用和连接。
2.  **二元归一**：整个系统仅由两种基本数据结构构成：**对象 (Object)** 和 **数组 (Array)**。万物皆可由此二者衍生。
3.  **扁平存储**：复杂的嵌套关系通过指针在物理层被分解为扁平化的键值对，极致利用 LMDB 的排序与遍历性能。

#### 二、两大核心数据库

整个系统建立在两个 LMDB 数据库之上，职责分明：

| 数据库名 | 核心职责 | LMDB 特性 | 描述                                            |
| :--------- | :----------- | :------------ | :-------------------------------------------- |
| **`main`** | **存储所有单一映射** | 标准 KV | 世界的"名词"。存储对象属性、根配置入口等所有 **一对一** 的关系。          |
| **`arr`** | **存储所有列表映射** | `MDB_DUPSORT` | 世界的"动词"和"集合"。存储数组元素、对象成员列表、定义等所有 **一对多** 的关系。 |

#### 三、核心数据结构

##### 1. 对象 (Object)
- **在 `main` 库中**：存储每个成员的 **值**。
    - **Key**: `<object_pointer><member_name>` (例如 `obj_abc:name`)
    - **Value**: **二进制安全的字节数组**。可以表示原始值（如字符串、数字的二进制形式）或**另一个实体的指针**（17字节二进制格式，如 `arr_123`, `obj_def`）。值的具体语义和编码/解码由上层应用解释。
*   **在 `arr` 库中**：存储该对象的 **成员列表**（相当于对象的"目录"）。
    *   **Key**: `<object_pointer>` (例如 `obj_abc`)
    *   **Value**: 该对象的所有 `<member_name>` (例如 `name`, `profile`, `hobbies`)

**这种设计实现了高效的"获取整个对象"操作：先通过 `arr` 库获取成员列表，再根据列表到 `main` 库中并发点查所有值。**

##### 2. 数组 (Array)
- **在 `arr` 库中**：
    - **Key**: `<array_pointer>` (例如 `arr_123`)
    - **Value**: **二进制安全的字节数组**。表示数组的元素，可以是原始值或另一个实体的指针（17字节二进制格式）。允许多个重复的 Key。

## 四、数据一致性模型与访问模式

### 4.1 对象/数组存在性规则
- **有效对象/数组**：指针在 `arr` 数据库中存在对应条目
- **空对象/空数组**：指针在 `arr` 数据库中对应值0

### 4.2 成员值完整性规则
- **合法成员**：必须在 `arr`（成员列表）和 `main`（值）中同时存在
- **缺失值**：`arr` 中定义但 `main` 中缺失 → 值为 `null`
- **数据完整性**：禁止"幽灵成员"（`main` 中存在但 `arr` 中未注册）

### 4.3 双模式数据访问策略

#### 宽松模式 (Loose Mode)
- **行为**：自动补全缺失数据，保证查询完成
- **返回**：完整数据结构 + 错误信息记录
- **适用场景**：普通业务、内容展示、配置读取

#### 严格模式 (Strict Mode)
- **行为**：遇到缺失数据立即终止
- **返回**：`null` + 错误信息记录  
- **适用场景**：金融系统、数据校验、测试环境

### 4.4 统一返回结构
两种模式都返回包含错误信息的统一结构，便于诊断和监控：

```c
// 读取错误代码定义
typedef enum {
    LMJCORE_READERR_NONE = 0,
    LMJCORE_READERR_ENTITY_NOT_FOUND = 1,   // 实体不存在
    LMJCORE_READERR_MEMBER_MISSING,         // 成员值缺失  
    LMJCORE_READERR_BUFFER_OVERFLOW,        // 缓冲区不足
    LMJCORE_READERR_LMDB_FAILED,            // LMDB操作失败
} lmjcore_read_error_code;

// 错误上下文
typedef struct {
    lmjcore_read_error_code code;
    union {
        struct {
            uint32_t name_offset;  // 在flat_buffer中的偏移
            uint16_t name_len;
        } member;
        struct {
            uint32_t index;
        } array;
        struct {
            int code;
        } error_code;
    } context;
    lmjcore_ptr entity_ptr;
} lmjcore_read_error;

// 成员描述符（完全基于偏移量）
typedef struct {
    uint32_t name_offset;   // 在flat_buffer中的偏移
    uint16_t name_len;
    uint32_t value_offset;  // 在flat_buffer中的偏移  
    uint16_t value_len;
} lmjcore_member_descriptor;

// 统一返回结构（完全自包含在result_buf中）
typedef struct {
    // 错误报告
    lmjcore_read_error errors[LMJCORE_MAX_READ_ERRORS];
    uint8_t error_count;
    
    // 对象数据布局信息
    uint16_t member_count;
    lmjcore_member_descriptor* members;
} lmjcore_result;

// result_buf 的内存布局：
// 内存布局定义：
// +------------------------+ ← result_buf (result)
// | lmjcore_result         | 固定头部
// +------------------------+
// | member_descriptors[]   | 描述符从前向后增长
// +------------------------+
// | ...                    |
// +------------------------+
// | name & value data      | 数据从后向前增长  
// +------------------------+ ← result_buf + result_buf_size
```

## 五、数据完整性保障

### 5.1 幽灵成员检测
- **最高级别警报**：幽灵成员（在 `main` 存在但 `arr` 中未注册）表示**原子性可能被破坏**
- **独立审计机制**：通过专用函数 `lmjcore_audit_object()` 检测
- **处理流程**：调用审计函数后上层应分析审计报告,发现"幽灵成员"后应立即停止写入，进行数据修复

### 5.2 原子性保证
内核确保以下操作在单个写事务内的原子性：
- **对象创建**：`main` 和 `arr` 数据库中的所有相关写入作为整体
- **成员操作**：成员值与成员列表的同步更新

## 六、关键特性与优势

1.  **极致性能**
    *   **读操作**：所有查询最终都被转换为对已知地址（指针）的直接内存访问或高效磁盘点查，完全避免了传统嵌套数据结构的递归解析开销。
    *   **写操作**：支持极细粒度的局部更新。修改嵌套数据中的任何部分，都只需操作与之直接关联的最小数据单元（单个键值对或数组元素），无需读写整个父级结构。

2.  **灵活性与一致性并存**
    *   **底层存储无模式 (Schema-less)**：可以动态、灵活地为任何对象添加或删除成员，无需预定义结构或执行迁移操作，适应快速变化的业务需求。
    *   **数据完整性保障**：明确的一致性规则和完整性审计机制。

3.  **继承LMDB的坚实根基**
    *   **完整ACID事务支持**：继承LMDB的内存映射、写时复制和单写多读设计，提供完全的事务支持，保证数据操作的原子性、一致性和持久化安全。
    *   **卓越的IO性能**：受益于LMDB的零拷贝、内存映射等特性，IO效率极高，尤其擅长读密集型场景。

4. **真正的无类型存储 (True Type-less Storage)**
    - **与 LMDB 原生对齐**：LMJCore 的 Value 完全继承 LMDB 的 **二进制安全** 特性，即为无类型、无模式的字节数组。所有类型信息（如整数、浮点数、字符串、指针）的序列化、反序列化以及语义解释职责均由上层应用承担。
    - **极致灵活性**：这使得存储层极其纯粹，能够容纳任何格式的数据，为上层的各种数据模型（如 JSON、Protocol Buffers 等）提供了坚实的基础。

## 七、架构与理念优势

5.  **概念极简与统一**
    *   整个复杂系统仅用"**对象 (Object)**"和"**数组 (Array)**"两个核心概念进行建模。这种高度抽象极大地降低了系统的理解和认知成本，使开发更加直观。

7.  **无限的可扩展性与灵活性**
    *   通过**指针 (Pointer)** 可以轻松建立任意复杂的数据关系和嵌套结构。

## 八、可选策略（需配置）

1.  **指针生成策略**
    *   支持外置配置不同的指针生成算法，以平衡不同场景下的需求：
        *   **UUID**：全局唯一，无需中心化协调，可读性较差。(默认,内核支持)
        *   **ULID**：时间有序且全局唯一，利于排序和调试。
        *   **自增ID**：长度短、可读性强，但可能需要协调以防止冲突。

2. 指针生成器接口
	- 内核仅规定函数签名如下`lmjcore_ptr_generator_fn`，具体实现由上层或默认生成器提供
	- 内核不检验唯一性，冲突时后写者胜；如需强校验，上层应在写入前调用 `exist` 探针。
3. 统一返回结构体内存归属 
	- 所有查询/审计函数返回的 `{data, errors}` 结构体由**调用方提供的缓冲区**承载；
	- 内核不再额外堆分配，生命周期随调用方缓冲区管理。

4. 根指针持久化格式
	- 内核工具函数统一把 17 字节指针转为 34 字符小写 HEX 字符串（无分隔符），
	- 配置文件可直接使用文本格式存储。


## 九、总结

**LMJCore** 框架是一个在LMDB之上构建的**语义化数据访问层**。它通过创新的"指针+扁平存储"设计，在保证极致性能的同时，提供了强大的数据一致性保障和灵活的访问模式。作为存储内核，LMJCore 为上层应用提供了稳定可靠的数据基石，支持构建各种复杂的数据处理系统。

---
**推荐阅读**:[[LMJCore 核心设计定义]] [[LMJCore 框架扩展：指针关系管理规范]] [[LMJCore 事务]]