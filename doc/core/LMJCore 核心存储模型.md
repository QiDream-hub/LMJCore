# LMJCore 核心存储模型

> **一句话定义**：  
> LMJCore 通过两片物理空间——**集合袋区（`arr`）** 与 **命名格子区（`main`）**——将任意嵌套的数据结构拆解为扁平的、可高效访问的片段，并通过全局唯一指针重新组合。

---

## 1. 两片存储空间

LMJCore 的全部数据存储在两个 LMDB 数据库中：

| 空间        | 名称     | 用途                                      | 关键特性                                                                                      |
| --------- | ------ | --------------------------------------- | ----------------------------------------------------------------------------------------- |
| **集合袋区**  | `arr`  | 存储**实体的关联项集合**  <br>（如对象的成员名列表、数组的元素列表） | - 启用 `MDB_DUPSORT`  <br>- 每个 Key 可关联多个 Value  <br>- **Value 按字典序自动排序**  <br>- **不保留插入顺序** |
| **命名格子区** | `main` | 存储**具体值**  <br>（如对象成员的实际内容）             | - 标准 KV 结构  <br>- Key = `[17B 实体指针][成员名]`  <br>- 成员天然隔离、点查 O(1)                           |

> 💡 所有实体（对象或数组）均由一个 **17 字节全局唯一指针**标识（首字节：`0x01`=对象，`0x02`=数组），该指针即为它们在 `arr` 和 `main` 中的“身份证”。

---

## 2. 对象如何存储？

以对象 `{ name: "Alice", age: 30 }` 为例：

### 步骤

1. 生成对象指针 `ptr_obj = 01...`（17 字节）
2. 在 `arr` 中注册成员名（顺序无关）：

   ```text
   arr[ptr_obj] → "age"
   arr[ptr_obj] → "name"
   ```

→ LMDB 内部会按 `"age" < "name"` 排序存储，但这**不影响语义**
1. 在 `main` 中存储具体值：

   ```text
   main[ptr_obj + "name"] → "Alice"
   main[ptr_obj + "age"]  → 30（二进制编码）
   ```


### 存储结构图示

```
arr（集合袋区）：
┌──────────────┬─────────────┐
│ Key: ptr_obj │ Value: "age"  │ ← 成员名集合（无序）
├──────────────┼─────────────┤
│ Key: ptr_obj │ Value: "name" │
└──────────────┴─────────────┘

main（命名格子区）：
┌───────────────────────┬─────────────┐
│ Key: ptr_obj+"name"   │ Value: "Alice" │ ← 独立格子，由“指针+名称”定位
├───────────────────────┼─────────────┤
│ Key: ptr_obj+"age"    │ Value: 30      │
└───────────────────────┴─────────────┘
```

> ✅ 对象成员的**存在性由 `arr` 定义**，**值由 `main` 提供**。两者必须一致，否则视为数据损坏。

---

## 3. 数组如何存储？

以数组 `["banana", "apple"]` 为例：

### 步骤

1. 生成数组指针 `ptr_arr = 02...`
2. 在 `arr` 中写入元素：

   ```text
   arr[ptr_arr] → "banana"
   arr[ptr_arr] → "apple"
   ```

1. **LMDB 自动按 Value 字典序排序**，实际存储为：
   ```text
   arr[ptr_arr] → "apple"
   arr[ptr_arr] → "banana"
   ```


> ⚠️ **重要**：`arr` **不保证插入顺序**。若应用需要有序数组，必须在 Value 中显式编码顺序信息，例如：

 ```c
 // 格式：[4B 小端序下标][原始值]
 arr[ptr_arr] → "\x00\x00\x00\x00banana"
 arr[ptr_arr] → "\x00\x00\x00\x01apple"
 ```

> 读取后按前 4 字节排序即可还原原始顺序。

---

## 4. 嵌套结构：靠指针链接

复杂结构通过**指针引用**实现：

```js
{
  user: { name: "Bob" },   // user 是一个对象
  tags: ["a", "b"]         // tags 是一个数组
}
```

- `main[parent_ptr + "user"] → child_obj_ptr`（17B）
- `main[parent_ptr + "tags"] → tags_arr_ptr`（17B）
- `child_obj_ptr` 和 `tags_arr_ptr` 分别指向 `arr`/`main` 中定义的子实体

→ 整个树状结构被**彻底扁平化**，但可通过指针完整重建。

---

## 5. 一致性规则

为保障数据正确性，LMJCore 强制以下规则：

| 规则                                | 说明                         |
| --------------------------------- | -------------------------- |
| **成员必须先在 `arr` 中声明**              | 不能直接向 `main` 写入未注册的成员      |
| **`main` 中存在但 `arr` 中缺失 → 幽灵成员**  | 属于严重数据损坏                   |
| **`arr` 中存在但 `main` 中缺失 → 合法缺失值** | 表示该成员尚未赋值                  |
| **Key 长度 ≤ 511 字节**               | 成员名最长 493 字节（17B 指针 + 成员名） |

---

## 6. 为什么这样设计？

|优势|说明|
|---|---|
|**极致读性能**|对象成员可并行点查 `main`，无需解析嵌套结构|
|**局部更新**|修改单个成员只需更新一个 `main` 格子|
|**灵活扩展**|上层可自由决定是否编码顺序、类型等元信息|
|**继承 LMDB 优势**|ACID、零拷贝、内存映射、崩溃安全|

---

## 总结：LMJCore 的存储心智模型

- **`arr` 是“集合袋”**：给定一个指针，你能拿到它所有的关联项（成员名或数组元素），但这些项是**无序集合**。
- **`main` 是“命名格子”**：每个格子由“指针 + 名称”唯一标识，值独立存储、强隔离。
- **指针是“胶水”**：将分散的片段重新组合成完整的逻辑实体。
- **顺序是应用语义**：内核不提供，但也不阻止——你可以在 Value 中编码任何排序逻辑。

> 这种设计让 LMJCore 在 **灵活性**（无模式、任意嵌套）与 **性能**（扁平、直接寻址）之间取得了极佳平衡。