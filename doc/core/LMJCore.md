# LMJCore 系统文档

> **当前时间：2025年10月13日**

## 一、系统概述

**LMJCore** 是一个基于 [LMDB](https://symas.com/lmdb/) 的高性能、嵌入式、无模式（Schema-less）键值存储引擎。

它并非传统意义上的完整数据库系统，而是一个专为极致性能与灵活性设计的**结构化数据存储内核**。其核心目标是作为上层查询系统的底层基石，提供高效、可靠的数据“存”、“取”、“管”能力。

### 核心定位
- **专注存储层**：不提供高级查询功能（如 SQL 或聚合操作）。
- **计算分离**：将“查”的职责交由上层实现（如未来的 `LMJQuery` 查询层）。
- **多引擎共享基础**：支持多个独立查询引擎同时访问同一份数据，便于构建分布式架构和实现水平扩展。

---

## 二、核心设计哲学

LMJCore 遵循三大设计原则：

| 原则 | 说明 |
|------|------|
| **指针化引用** | 所有数据实体（对象、数组）通过全局唯一的字符串指针标识和连接。 |
| **二元归一** | 整个系统仅由两种基本结构构成：**对象 (Object)** 和 **数组 (Array)**，所有复杂结构均可由此衍生。 |
| **扁平化存储** | 利用指针将嵌套结构拆解为扁平化的键值对，充分发挥 LMDB 的排序与遍历优势。 |

---

## 三、双数据库架构

整个系统建立在两个 LMDB 数据库之上，职责分明：

| 数据库名 | 职责描述 | LMDB 特性 | 类比意义 |
|---------|----------|-----------|--------|
| `main` | 存储所有单一映射关系（一对一） | 标准 KV 模式 | “名词” —— 如对象属性、根配置入口等 |
| `arr`  | 存储所有列表映射关系（一对多） | 启用 `MDB_DUPSORT` 支持重复键 | “动词”或“集合” —— 如数组元素、成员列表等 |

---

## 四、核心数据结构

### 4.1 对象 (Object)

- **在 `main` 库中**：
  - **Key**: `<object_pointer><member_name>`  
    示例：`obj_abc:name`
  - **Value**: 二进制安全字节数组，表示原始值或指向其他实体的指针（17 字节二进制格式，如 `arr_123`, `obj_def`）。
  
- **在 `arr` 库中**：
  - **Key**: `<object_pointer>`  
    示例：`obj_abc`
  - **Value**: 该对象的所有成员名称（即 `<member_name>` 列表），用于维护成员目录。

> ✅ **高效读取策略**：先从 `arr` 获取成员名列表，再并发点查 `main` 中对应值。

---

### 4.2 数组 (Array)

- **在 `arr` 库中**：
  - **Key**: `<array_pointer>`  
    示例：`arr_123`
  - **Value**: 二进制安全字节数组，表示数组元素（可为原始值或指针）
  - 支持同一 Key 多个 Value（依赖 `MDB_DUPSORT`）

---

## 五、数据一致性模型

### 5.1 实体存在性规则

| 状态 | 判断条件 |
|------|--------|
| 有效对象/数组 | 指针在 `arr` 数据库中有对应条目 |
| 空对象/空数组 | 指针在 `arr` 中存在但无任何值（长度为 0） |

---

### 5.2 成员值完整性规则

- **合法成员定义**：成员名必须出现在该对象指针对应的 `arr` 条目中。
- **成员值状态**：
  - **已赋值**：在 `arr` 注册，并且在 `main` 中有对应值。
  - **缺失值 (Missing Value)**：在 `arr` 注册，但在 `main` 中无值 → 允许的中间状态。
- **禁止“幽灵成员”**：
  - 若某键存在于 `main`，但未在 `arr` 中注册，则视为严重数据损坏。
  - 正常操作下不应出现此情况。

> ⚠️ **重要区别**：
> - “缺失值”是**允许的状态**，不影响数据完整性。
> - “幽灵成员”是**非法状态**，需立即修复。

---

### 5.3 双模式数据访问策略

| 模式 | 行为 | 返回结果 | 适用场景 |
|------|------|----------|----------|
| **宽松模式 (Loose Mode)** | 自动补全缺失数据，尽力返回完整结构 | 完整数据 + 错误信息记录 | 普通业务、内容展示、配置读取 |
| **严格模式 (Strict Mode)** | 遇到缺失立即终止 | `null` + 错误信息 | 金融系统、数据校验、测试环境 |

> ✅ 两种模式均返回统一结构，包含错误诊断信息，便于监控与调试。

---

### 5.4 统一返回结构定义

所有查询操作返回如下自包含结构，全部内存由调用方提供（零堆分配）。

#### 错误码定义
```c
typedef enum {
    LMJCORE_READERR_NONE = 0,
    LMJCORE_READERR_ENTITY_NOT_FOUND,   // 实体不存在
    LMJCORE_READERR_MEMBER_MISSING,     // 成员值缺失
    LMJCORE_READERR_BUFFER_OVERFLOW,    // 缓冲区不足
    LMJCORE_READERR_LMDB_FAILED         // LMDB 操作失败
} lmjcore_read_error_code;
```

#### 错误上下文
```c
typedef struct {
    lmjcore_read_error_code code;
    union {
        struct {
            uint32_t name_offset;  // 在 flat_buffer 中的偏移
            uint16_t name_len;
        } member;
        struct {
            uint32_t index;
        } array;
        struct {
            int code;
        } error_code;
    } context;
    lmjcore_ptr entity_ptr;
} lmjcore_read_error;
```

#### 成员描述符
```c
typedef struct {
    uint32_t name_offset;   // 名称在缓冲区中的偏移
    uint16_t name_len;
    uint32_t value_offset;  // 值在缓冲区中的偏移
    uint16_t value_len;
} lmjcore_member_descriptor;

typedef struct {
    uint32_t value_offset;
    uint16_t value_len;
} lmjcore_value_descriptor;
```

#### 统一结果结构
```c
typedef struct {
    lmjcore_read_error errors[LMJCORE_MAX_READ_ERRORS];
    uint8_t error_count;

    size_t count;
    union {
        lmjcore_member_descriptor* members;
        lmjcore_value_descriptor* value;
    } descriptor;
} lmjcore_result;
```

#### 内存布局（`result_buf`）
```
+------------------------+  ← result_buf (起始地址)
| lmjcore_result         |  固定头部
+------------------------+
| member_descriptors[]   |  描述符从前向后增长
+------------------------+
| ...                    |
+------------------------+
| name & value data      |  实际数据从后向前填充
+------------------------+  ← result_buf + result_buf_size
```

> 🔁 所有字段使用偏移量而非指针，确保跨进程/序列化兼容性。

---

## 六、数据完整性保障机制

### 6.1 幽灵成员检测

- **最高优先级警报**：“幽灵成员”表明原子性可能已被破坏。
- **审计接口**：通过 `lmjcore_audit_object()` 函数主动扫描并报告异常。
- **处理流程**：
  1. 调用审计函数；
  2. 分析报告；
  3. 发现幽灵成员 → 立即停止写入；
  4. 进行数据修复。

---

### 6.2 原子性保证

内核确保以下操作在单个写事务中原子完成：

| 操作类型 | 原子性范围 |
|--------|------------|
| 对象创建 | `main` 与 `arr` 相关写入作为一个整体提交 |
| 成员操作 | 成员值更新与成员列表同步更新不可分割 |

---

## 七、关键特性与优势

| 特性 | 说明 |
|------|------|
| **极致性能** | - 读：转换为直接内存访问或高效磁盘点查，避免递归解析开销<br>- 写：支持极细粒度局部更新，无需重写父结构 |
| **灵活与一致并存** | - 无模式设计：动态增删成员，无需迁移<br>- 明确一致性规则 + 审计机制保障安全 |
| **继承 LMDB 优势** | - 完整 ACID 事务支持（MVCC、COW）<br>- 单写多读、零拷贝、内存映射 → IO 效率极高 |
| **真正无类型存储** | Value 为纯二进制字节数组，类型语义由上层解释（支持 JSON、Protobuf 等任意编码） |
| **概念极简统一** | 仅用“对象”和“数组”建模一切，降低认知成本 |
| **无限可扩展性** | 通过指针轻松构建任意复杂关系与嵌套结构 |

---

## 八、可选配置策略

### 8.1 指针生成策略（可插拔）

| 策略    | 特点                | 是否默认      |
| ----- | ----------------- | --------- |
| UUID  | 全局唯一，无需协调，可读性差    | 可选(需显式传入) |
| ULID  | 时间有序、全局唯一，利于排序与调试 | 可选        |
| 自增 ID | 长度短、可读性强，需防冲突     | 需外部协调     |

> 📌 接口定义：`lmjcore_ptr_generator_fn`，具体实现由上层提供。

> ⚠️ **警告**：内核不验证指针唯一性，冲突时遵循 LMDB “后写者胜”原则。使用自定义生成器（尤其是自增 ID）时，开发者须自行保证全局唯一，否则可能导致数据覆盖或丢失。

---

### 8.2 统一返回结构内存管理

- 所有查询与审计函数返回的 `{data, errors}` 结构均承载于**调用方提供的缓冲区**。
- 内核不再进行额外堆分配。
- 生命周期由调用方控制，提升性能与安全性。

---

### 8.3 根指针持久化格式

- 工具函数自动将 17 字节二进制指针转为 34 字符小写 HEX 字符串（无分隔符）。
- 示例：`746573746f626a5f313233`（对应 ASCII "testobj_123"）
- 配置文件可直接使用文本格式存储指针。

---

## 九、总结

**LMJCore** 是在 LMDB 基础上构建的一层**语义化数据访问框架**。它通过创新性的“**指针 + 扁平存储**”设计，在保留 LMDB 极致性能的同时，提供了强大的数据一致性保障与灵活的访问模式。

作为底层存储内核，LMJCore 为上层应用提供了稳定、可靠、高性能的数据基石，适用于需要高并发、低延迟、强一致性的现代数据处理系统。

---

## 延伸阅读建议

- [[LMJCore 核心设计定义]]
- [[LMJCore 框架扩展：指针关系管理规范]]
- [[LMJCore 事务]]

--- 

✅ **文档状态**：已整理完毕  
📅 **最后更新时间**：2025年10月13日