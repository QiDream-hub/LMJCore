# LMJCore 实现细则与集成指南

当前时间：2025年10月13日

---

## 一、指针生成机制

### 1. 内核职责与默认提供

- **内核核心职责**  
  **不负责生成指针**。内核仅验证传入指针的格式合法性（17字节，首字节为有效实体类型）。  
- 指针的全局唯一性与生成逻辑**完全由上层应用保证**。

- **可插拔接口**  
  内核定义函数指针类型：
  ```c
  typedef int (*lmjcore_ptr_generator)(void *ctx, uint8_t out[17]);
  ```
  上层可在初始化时传入自定义实现（如 ULID、雪花算法等），实现灵活扩展。

---

### 2. 自增ID注意事项

若上层选择自增 ID 作为指针生成策略：

- **必须自行解决** 分布式环境下的 ID 分配与冲突问题，**内核不提供协调机制**。
- 生成的16字节编号部分应按 **大端序（Big-endian）填充**，以确保在 LMDB 中按键排序时保持数字顺序一致性。
- ⚠️ 风险提示：重复指针将导致“后写者胜”覆盖行为，可能引发数据丢失或逻辑混乱。

---

## 二、成员名称的编码与存储

### 1. 内核视角

- 内核将成员名称视为 **二进制安全的字节数组（Binary-safe Bytestring）**。
- 不进行任何编码假设或转换 —— 可为 UTF-8 字符串、ASCII、哈希值甚至任意二进制数据。
- 成员名称长度受 LMDB Key 最大长度限制（通常约 511 字节），扣除 17 字节对象指针后，实际可用空间约为 **494 字节**。

---

### 2. 上层建议

- ✅ **推荐使用 UTF-8 编码字符串**，以保证可读性与通用兼容性。
- ❌ 避免使用过长名称，防止触及 LMDB 键长上限。
- 若需高性能索引，可考虑使用固定长度哈希（如 SHA-1 截断）作为成员名。

---

## 三、值的序列化与解释

- 所有值（Value）均作为 **二进制安全字节数组** 存储，完全对齐 LMDB 原生语义。
- 内核 **不关心也不干预** 值的内容结构 —— 无论是整数、浮点、JSON 还是嵌套对象指针。
- 值的解释权完全由上层应用掌控。
- 上层需统一采用一致的序列化协议，例如：
  - MessagePack
  - JSON Binary Format
  - Protocol Buffers
  - 自定义二进制格式

> 🔧 提示：建议在系统层面约定统一的序列化标准，并通过工具函数封装编解码逻辑。

---

## 四、数据访问模式（宽松/严格模式）的实现层级

- **宽松模式（Loose Mode）** 与 **严格模式（Strict Mode）** 由 LMJCore 内核原生支持。
- 数据读取函数（如 `lmjcore_obj_get`）接受一个模式标志参数（如 `lmjcore_query_mode`）。
- 内核根据该标志决定缺失处理行为：
  - **宽松模式**：自动补全缺失成员为 `null` 或空数组，尽力返回完整结构。
  - **严格模式**：一旦发现成员缺失即终止读取，返回错误信息。
- 统一返回结构（含 `data` 和 `errors` 字段）由内核构造并写入调用方缓冲区。

✅ 适用场景对比：

| 模式 | 适用场景 |
|------|----------|
| 宽松模式 | 普通业务逻辑、内容展示、配置加载 |
| 严格模式 | 金融交易、数据校验、测试断言 |

---

## 六、跨事务的指针可见性与缓存一致性

- LMJCore 完全继承并映射 LMDB 的 **MVCC（多版本并发控制）语义**。
- 在一个写事务中新创建的指针，在提交成功后，对所有**之后开启的只读事务立即可见**。
- 已开启的只读事务（在写事务提交前启动）无法看到新数据，其视图为事务开始时的快照。

### 缓存处理建议

- 若上层应用自行缓存了指针或实体数据，必须遵循以下原则：
  - 在事务边界刷新本地缓存。
  - 监听写事务提交事件以触发失效。
  - 避免长期持有跨事务的数据引用。

> ✅ 推荐实践：结合 `lmjcore_exist()` 探针函数验证缓存有效性。

---

## 七、数据审计与修复工具

### 1. 审计函数 `lmjcore_audit_object`

- **功能**：检查指定对象指针的数据完整性，重点检测“幽灵成员”。
- **输出**：返回详细审计报告结构，包含：
  - 对象指针
  - 整体状态（完整 / 有缺失值 / 有幽灵成员）
  - 错误列表，每项包括：
    - 违规键的完整二进制 Key（`<对象指针><成员名>`）
    - 错误类型（如 `LMJCORE_AUDIT_ERR_GHOST_MEMBER`）

🔧 工具支持：提供辅助函数将二进制 Key 转换为可读 HEX 格式。

---

### 2. 修复函数 `lmjcore_repair_object`

- **功能**：尝试修复审计发现的问题。
- **针对“幽灵成员”**：
  - 安全删除其在 `main` 数据库中的键值对。
  - **不会重新注册为合法成员** —— 此操作需由上层显式完成（因无法判断原始意图）。
- **输入**：对象指针、成员名列表（用于上下文判断）
- **输出**：修复报告，列出已删除的幽灵成员键。
- **事务保证**：
  - 修复操作在独立写事务中执行，具备原子性。
  - 成功则全部生效；失败则自动回滚，数据库状态不变。
- **并发限制**：
  - 修复期间阻塞其他写事务（遵循 LMDB 单写原则）。
  - 已开启的只读事务不受影响。

---

## 八、错误码定义与继承规范

### 1. 错误码继承原则

- LMJCore 作为 LMDB 的语义化封装层，**完全透传原生 LMDB 错误码**，便于底层异常定位。

---

### 2. 错误码空间划分

| 组件层级         | 错误码范围           | 说明                   |
| ------------ | --------------- | -------------------- |
| LMDB 原生错误    | -30799 ~ -30779 | LMDB 内核定义的标准错误码，直接透传 |
| LMJCore 内核错误 | -32000 ~ -32999 | LMJCore 特有的语义化错误码    |
| 未来扩展层错误      | -33000 ~ -33999 | 为查询层、网络层等预留          |
| 用户自定义错误      | -34000 ~ -34999 | 供应用层业务逻辑使用           |

---

### 3. 核心错误码示例

```c
#define LMJCORE_SUCCESS                          0
#define LMJCORE_ERROR_INVALID_PARAM         -32000 // 参数错误
#define LMJCORE_ERROR_MEMBER_TOO_LONG       -32001 // 成员名过长
#define LMJCORE_ERROR_ENTITY_NOT_FOUND      -32002 // 实体未找到（无效指针）
#define LMJCORE_ERROR_GHOST_MEMBER          -32003 // 发现幽灵成员
#define LMJCORE_ERROR_INVALID_POINTER       -32004 // 指针格式错误
#define LMJCORE_ERROR_BUFFER_TOO_SMALL      -32005 // 缓冲区不足
#define LMJCORE_ERROR_MEMORY_ALLOCATION_FAILED -32006 // 内存分配失败
#define LMJCORE_ERROR_STRICT_MODE_VIOLATION -32007 // 严格模式下读取失败
```

---

### 4. 错误处理建议

- **LMDB 错误**：检查事务状态、磁盘空间、文件权限等系统级问题。
- **LMJCore 错误**：验证输入参数、检查数据完整性规则是否被破坏。
- **分层诊断**：通过错误码范围快速定位问题所属层级（底层存储 vs 语义层 vs 业务层）。

✅ 优势：全局唯一、可追溯、利于自动化监控与告警。

---

## 九、官方支持的“分步初始化”模式

- LMJCore 提供 `lmjcore_register_member` API，允许在 `arr` 数据库中预先注册成员名，而无需立即赋值。
- 此机制支持以下高级模式：
  - 结构先行（Schema-first）
  - 延迟赋值（Lazy Initialization）
  - 分阶段构建复杂对象

### 使用说明

- 注册后，该成员处于“缺失值”状态，属于合法中间态。
- 后续可通过 `lmjcore_write_member` 补充具体值。
- 开发者应确保最终完成赋值，以维持业务逻辑完整性。

> ✅ 场景示例：用户注册流程中先创建账户结构，后续异步填充头像、地址等非关键字段。

---

✅ 文档状态：已整理完毕  
📅 最后更新时间：2025年10月13日