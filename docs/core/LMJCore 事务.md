# LMJCore 事务控制扩展设计规范

当前时间：2025年10月13日

---

## 一、设计理念

### 1.1 核心原则

- **存储与调度分离**  
  LMJCore 内核仅负责数据操作的原子性与正确性，**事务的调度与提交策略完全由上层应用控制**。

- **显式事务边界**  
  所有数据操作必须发生在显式定义的事务上下文中，杜绝隐式事务带来的不确定性与性能瓶颈。

- **映射原生语义**  
  事务模型直接映射 LMDB 的“单写多读”并发语义，不引入中间抽象层，确保行为可预测、性能可预期。

---

### 1.2 目标

- 为上层应用提供最大化的**事务调度灵活性**，以优化写锁占用时间，提升读并发性能。
- 保持 LMJCore 内核的**极简性与稳定性**，避免将复杂调度逻辑下沉至存储层。

---

## 二、事务模型定义

### 2.1 事务类型

系统定义两种基本事务类型：

| 类型标志 | 允许操作 | 并发性 |
|--------|---------|--------|
| `LMJCORE_TXN_READONLY` | 仅数据读取 | 可无限并发，不阻塞且不被阻塞 |
| `LMJCORE_TXN_WRITE` | 读取与写入 | 全局唯一，遵循单写者原则 |

> ✅ 所有事务必须通过 `lmjcore_txn_begin()` 显式创建，并指定类型。

---

### 2.2 事务生命周期规则

- **创建**  
  由上层应用显式调用 API 创建，并明确指定事务类型（只读 / 写）。

- **使用**  
  所有数据操作 API（如 `lmjcore_write_member`、`lmjcore_obj_get`）必须在一个有效的事务上下文中执行。

- **终止**

  - **提交（Commit）**  
    写事务通过提交使其所有修改持久化。提交后，该事务句柄立即失效，不可复用。

  - **中止（Abort）**  
    读事务或未提交的写事务可通过中止释放资源。中止后，事务句柄失效。

- **句柄单次有效性**  
  每个事务句柄仅能用于一组连续操作，提交或中止后即不可再使用。

---

## 三、上层调度策略规范

### 3.1 职责划分

| 组件 | 职责 |
|------|------|
| **LMJCore 内核** | 保证单个事务内操作的原子性、一致性与隔离性（ACI） |
| **上层应用** | 决定何时开始写事务、累积多少操作后提交、如何处理失败重试 |

> ✅ 内核不干预提交时机，仅提供原子执行能力。

---

### 3.2 推荐策略模式

以下为上层可实现的最佳实践策略（非强制）：

#### 批量累积策略

- **规则**：将一个写事务内的操作数量累积到预定阈值（如 100 次 PUT 操作）后一次性提交。
- **优点**：减少事务开销，提升吞吐量。
- **适用场景**：大规模数据导入、非实时性后台任务。

#### 关键路径立即提交策略

- **规则**：维护一个“关键指针”白名单。任何操作若涉及白名单中的指针，则立即提交当前事务并开启新事务。
- **优点**：保证核心元数据的实时持久化。
- **适用场景**：金融账户余额、系统配置等关键状态更新。

#### 时间窗口策略

- **规则**：写事务开启后，在固定时间窗口（如 100ms）内累积操作，超时后自动提交。
- **优点**：平衡实时性与吞吐量。
- **适用场景**：在线服务、事件流处理系统。

---

### 3.3 错误处理约定

- 事务提交可能失败（如磁盘满、系统错误），返回非 `LMJCORE_SUCCESS` 错误码。
- 上层必须实现：
  - **重试逻辑**：对可恢复错误进行指数退避重试。
  - **补偿机制**：对不可逆操作记录日志以便人工干预。
- **建议**：维护一个“操作日志”缓冲区，在提交失败时重新应用或回滚。

---

## 四、内核行为规范

### 4.1 原子性保证

内核确保以下复合操作在单个写事务内的原子性：

- **对象创建**  
  在 `main` 和 `arr` 数据库中的所有相关字节数组写入作为一个不可分割的整体提交。

- **成员操作**  
  对对象成员的增、删、改操作，保证其对应的 Value 与 `arr` 数据库中成员列表的同步更新。

> 🔐 内核仅保证字节数组的正确写入，不解释其内容语义。

---

### 4.2 指针有效性

- 在写事务提交前，新创建的指针对外部事务**不可见**。
- 只有当事务成功提交后，新指针才被视为有效，并可被后续开启的事务访问。

---

### 4.3 成员状态有效性

- 在写事务中通过 `lmjcore_register_member` 新注册的成员：
  - 提交成功后，对所有之后开启的只读事务可见。
  - 状态为“缺失值”（Missing Value）。

- 在写事务中通过 `lmjcore_write_member` 为“缺失值”成员赋值：
  - 仅在事务提交成功后，新值才对后续事务可见。

---

## 五、总结

本规范确立了 LMJCore 存储内核与上层应用之间基于**显式事务控制**的协作范式。

通过将事务调度权彻底上交，LMJCore 在保持自身内核纯净与高效的同时，为上层优化并发性能提供了根本性的自由度。

上层架构师可根据具体业务特征和访问模式，设计最优化的批量提交策略，在 LMDB 单写锁的约束下，实现系统整体吞吐量的最大化。

> ✅ 核心价值：**内核做减法，上层做加法** —— 极致性能与极致灵活的统一。

---

✅ 文档状态：已整理完毕  
📅 最后更新时间：2025年10月13日