# LMJCore 实现细则与集成指南

## 一、指针生成机制

### 1. 内核职责与默认提供
- **内核核心职责**：保证生成的指针（17字节）**全局唯一**且**符合二进制格式**（1字节类型前缀 + 16字节唯一编号）。
- **默认生成器**：LMJCore 内核将提供一个**默认的指针生成器**。
    - 该生成器使用 **UUIDv4** 算法生成128位唯一编号。
    - 上层应用在调用 `lmjcore_init` 接口时，若不指定指针，内核将使用此默认生成器。
- **可插拔接口**：内核将定义一个指针生成函数接口（如 `lmjcore_ptr_generator`）。上层应用可以在初始化时传入自定义生成函数，以实现 ULID、雪花算法等特定策略。

### 2. 自增ID注意事项
- 若上层选择自增ID作为指针生成策略，**必须自行解决ID分配与冲突问题**，因为内核不提供分布式协调机制。
- 自增ID生成的指针，其16字节编号部分应遵循大端序填充，以确保LMDB键排序符合数字顺序。

## 二、成员名称的编码与存储

### 1. 内核视角
- 内核将成员名称视为**二进制安全的字节数组 (Binary-safe Bytestring)**，不进行任何编码假设或转换。
- 这意味着上层可以使用UTF-8字符串、ASCII、甚至纯二进制数据（如哈希值）作为成员名称。

### 2. 上层建议
- **推荐使用UTF-8编码**的字符串，以保证可读性和通用性。
- 成员名称的长度受LMDB的Key最大长度限制（通常约为511字节），上层应避免使用过长的名称。

## 三、值的序列化与解释

- 内核将所有值（Value）作为**二进制安全的字节数组**存储，与LMDB原生对齐。
- **值的解释权完全在上层**。内核不关心字节数组的内容，也不提供任何内置的序列化/反序列化工具。
- 上层应用需自行统一序列化协议（如MessagePack、JSON Binary、Protocol Buffers或自定义格式）用于存储整数、浮点数、字符串、嵌套对象指针等。

## 四、数据访问模式（宽松/严格模式）的实现层级

- 宽松模式（Loose Mode）与严格模式（Strict Mode）是**由LMJCore内核原生支持**的特性。
- 内核的数据读取函数（如 `lmjcore_obj_get`）将接受一个模式标志参数（如 `lmjcore_query_mode`）。
- 内核根据该标志决定在遇到数据缺失（如成员在`arr`中注册但在`main`中缺失）时的行为：是补全`null`（宽松）还是立即终止（严格）。
- 统一返回结构（包含`data`和`errors`字段）也由内核构造并返回。

## 六、跨事务的指针可见性与缓存一致性

- LMJCore 完全继承并映射 **LMDB 的 MVCC（多版本并发控制）语义**。
- 在一个写事务中**新创建**的指针，在该事务**提交成功后**，将对所有**之后开启**的只读事务立即可见。
- 正在进行的只读事务（在写事务提交前开启）**看不到**新提交的指针，它们看到的是数据库在事务开始时的快照。
- 上层应用若在使用指针时自行缓存了数据，需根据LMDB的事务机制妥善处理缓存失效，建议在事务边界刷新缓存。

## 七、数据审计与修复工具

### 1. 审计函数 `lmjcore_audit_object`
- **功能**：检查指定对象指针的数据完整性，重点检测“幽灵成员”。
- **输出**：返回一个详细的审计报告结构。该结构包含：
    - 对象指针。
    - 状态（完整、有缺失值、有幽灵成员）。
    - 一个错误列表，每个错误条目将明确包含：
        - **违规键的完整Key**：即 `<对象指针(17字节)><成员名称(变长字节序列)>` 的二进制形式。上层可借助内核工具函数将其转换为可读格式。
        - 错误类型（如 `LMJCORE_AUDIT_ERR_GHOST_MEMBER`）。

### 2. 修复函数 `lmjcore_repair_object`
- **功能**：尝试修复审计发现的问题。对于“幽灵成员”，其修复方式是**安全地删除**其在`main`数据库中对应的键值对;对于重新注册为对象成员则由上层重新注册，因为LMJCore无法保证数据是否完整需要上层验证。
- **输入**：一个对象指针，对象成员。
- **输出**：返回修复报告，列出已删除的幽灵成员键。
- **事务保证**：修复操作在**独立的写事务中原子性执行**。即在修复过程中：
	- 要么成功删除所有发现的幽灵成员，修复报告完整返回；
	- 要么因任何原因失败，所有更改自动回滚，数据库保持修复前状态。
- **并发限制**：修复期间，其他写事务将被阻塞（遵循LMDB单写原则），但已开启的只读事务不受影响。

## 八、错误码定义与继承规范

### 1 错误码继承原则
LMJCore 作为 LMDB 的语义化封装层，完全继承并透传 LMDB 的原生错误码，确保底层存储异常能够被准确识别和处理。

### 2 错误码空间划分

| 组件层级             | 错误码范围               | 说明                           |
| ---------------- | ------------------- | ---------------------------- |
| **LMDB 原生错误**    | `-30799` ~ `-30779` | LMDB 内核定义的标准错误码，LMJCore 直接透传 |
| **LMJCore 内核错误** | `-32000` ~ `-32999` | LMJCore 特有的语义化错误码            |
| **未来扩展层错误**      | `-33000` ~ `-33999` | 为查询层、网络层等上层组件预留              |
| **用户自定义错误**      | `-34000` ~ `-34999` | 供应用层业务逻辑使用                   |

### 3 核心错误码示例
```c
// LMJCore 内核错误码（部分示例）
#define LMJCORE_ERR_MEMBER_TOO_LONG    -32001  // 成员名称超长
#define LMJCORE_ERR_INVALID_PTR_FORMAT -32002  // 指针格式无效
#define LMJCORE_ERR_BUFFER_TOO_SMALL   -32003  // 输出缓冲区不足
#define LMJCORE_ERR_GHOST_MEMBER       -32004  // 检测到幽灵成员
#define LMJCORE_ERR_AUDIT_FAILED       -32005  // 数据审计失败
```

### 4 错误处理建议
- **LMDB 错误**：通常表示底层存储异常，应检查事务状态、磁盘空间等系统级问题
- **LMJCore 错误**：表示语义层逻辑异常，应验证输入参数和业务逻辑
- **分层诊断**：通过错误码范围可快速定位问题发生的组件层级

这样的划分确保了错误码的全局唯一性和可追溯性，便于系统的分层调试和问题定位。