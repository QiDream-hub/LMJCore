# LMJCore 事务控制扩展设计规范

## 一、设计理念

### 1.1 核心原则
- **存储与调度分离**：LMJCore 内核仅负责数据操作的原子性与正确性，事务的调度与提交策略完全由上层应用控制。
- **显式事务边界**：所有数据操作必须发生在显式定义的事务上下文中，杜绝隐式事务带来的不确定性。
- **映射原生语义**：事务模型直接映射 LMDB 的“单写多读”并发语义，不引入中间抽象层。

### 1.2 目标
- 为上层应用提供最大化的事务调度灵活性，以优化写锁占用时间，提升读并发性能。
- 保持 LMJCore 内核的极简性与稳定性。

## 二、事务模型定义

### 2.1 事务类型
系统定义两种基本事务类型：

| 类型 | 标志 | 允许操作 | 并发性 |
|------|------|----------|--------|
| **只读事务** | `LMJCORE_TXN_READONLY` | 仅数据读取 | 可无限并发，不阻塞且不被阻塞 |
| **写事务** | `LMJCORE_TXN_WRITE` | 读取与写入 | 全局唯一，遵循单写者原则 |

### 2.2 事务生命周期规则
1. **创建**：事务必须由上层应用显式创建，并明确指定其类型（读/写）。
2. **使用**：所有数据操作 API 必须在一个有效的事务上下文中执行。
3. **终止**：
   - **提交**：写事务通过提交使其所有修改持久化。提交后，该事务句柄失效。
   - **中止**：读事务或未提交的写事务通过中止来释放资源。中止后，该事务句柄失效。
4. **句柄单次有效性**：每个事务句柄仅能用于一组连续操作，并在提交或中止后立即失效，不可重用。

## 三、上层调度策略规范

### 3.1 职责划分
- **LMJCore 内核**：保证单个事务内操作的原子性、一致性。
- **上层应用**：负责决定何时开始一个写事务、累积多少操作后提交、以及如何处理事务失败。

### 3.2 推荐策略模式
上层应用可根据业务场景实现以下策略（非内核强制，仅为最佳实践）：

1. **批量累积策略**
   - **规则**：将一个写事务内的操作数量累积到预定阈值（如100次PUT操作）后一次性提交。
   - **适用场景**：大规模数据导入、非实时性的后台计算任务。

2. **关键路径立即提交策略**
   - **规则**：定义一个“关键指针”白名单。任何操作若涉及白名单中的指针，则立即提交当前写事务并开启新事务。
   - **适用场景**：需要保证核心元数据实时持久化的系统。

3. **时间窗口策略**
   - **规则**：写事务开启后，在一个固定时间窗口（如100毫秒）内累积操作，超时后自动提交。
   - **适用场景**：平衡实时性与吞吐量的在线服务。

### 3.3 错误处理约定
- 事务提交可能失败（如系统错误、磁盘满）。上层应用必须实现重试或回滚逻辑。
- 建议上层维护一个“操作日志”，在事务提交失败时，能够重新应用这批操作或进行补偿。

## 四、内核行为规范

### 4.1 原子性保证
- **原子性保证**：对于以下复合操作，内核确保其在单个写事务内的原子性。内核仅保证这些**无类型的字节数组**被正确地、原子地写入或删除，而不关心其内容。
    - **对象创建**：在 `main` 数据库和 `arr` 数据库中的所有相关**字节数组**的写入作为一个不可分割的整体。
    - **成员操作**：对对象成员的增、删、改操作，保证其对应的 Value（字节数组）与 `arr` 数据库中成员列表的同步更新。

### 4.2 指针有效性
- 在写事务提交前，于该事务内**新创建**的指针对外部其他事务不可见。
- 只有当事务成功提交后，新指针才被视为有效并可被其他事务访问。


## 五、总结

本规范确立了 LMJCore 存储内核与上层应用之间基于显式事务控制的协作范式。通过将**事务调度权**彻底上交，LMJCore 在保持自身内核纯净与高效的同时，为上层优化并发性能提供了根本性的自由度。上层应用的架构师可以根据具体的业务特征和数据访问模式，设计出最优化的事务批量提交策略，从而在 LMDB 单写锁的约束下，实现系统整体吞吐量的最大化。