# LMJCore 框架扩展：指针关系管理规范

## 一、核心原则：职责分离

LMJCore 作为存储内核，恪守“存、取、管”的核心定位。对于指针与对象的关系管理，框架采用明确的职责分离设计：

- **LMJCore 内核层**：负责安全地创建数据实体并生成唯一指针，确保基础操作的原子性与一致性。
- **上层应用/查询层**：负责接收指针，并根据业务语义将其注册到相应的关系索引中。

## 二、运作机制

### 1. 指针生成与返回
- 当通过 LMJCore 创建新的对象或数组时，内核会生成全局唯一的指针（如 `obj_abc123`）。
- 该指针作为创建操作的结果返回给调用者。

### 2. 关系注册(非强制,如需要反向索引)
- **高层应用**在接收到指针后，必须立即（通常在同一个事务中）将该指针记录到预定义的**关系注册结构**中。
- 这些结构包括但不限于：
  - 类型分类数组（如 `arr_all_users`）
  - 名称索引映射（如 `object:user_index:john_doe`）
  - 标签集合数组（如 `arr_tag_vip_users`）

### 3. 查询路径
- 所有基于语义的查询（如“查找用户john_doe”）都应通过查询预先构建的**关系注册结构**开始，获取目标指针后再进行数据访问。
- 不建议为进行关系查询而执行全库扫描,因为性能消耗较大。

### 4. 指针生成器接口
- 上层可自行实现 UUIDv4 / ULID / 雪花等策略，或沿用内核默认实现。
- 内核仅声明签名：
```c
typedef int (*lmjcore_ptr_generator_fn)(void *ctx, uint8_t out[17]);
```

### 5. exist探针
- **函数签名**: `int lmjcore_exist(lmjcore_txn txn, lmjcore_ptr ptr);`
- **返回值语义**:
  - **返回 1**: 指针在 `arr` 数据库中存在对应条目，表示该指针指向一个**有效**的数据实体（对象或数组）。
  - **返回 0**: 指针在 `arr` 数据库中**不存在**对应条目，表示该指针为**无效指针**，不指向任何有效数据实体。
  - **返回负数**: 表示 LMDB 操作失败（如事务无效、IO错误等），具体错误码参见 LMJCore 错误码定义。
- **用途**: 用于在写入前检查指针唯一性（如需强校验），或验证指针有效性。
```c
int exist(lmjcore_txn txn,lmjcore_ptr ptr);
```

## 三、架构优势

1.  **内核纯净**：LMJCore 内核保持极简与稳定，不包含任何业务逻辑。
2.  **极致灵活**：高层可以自由定义任何形式的索引模型（如关系型、标签型、搜索型），无需内核支持。
3.  **明确边界**：开发者对“数据如何存储”和“数据如何查找”拥有清晰的控制权与责任边界。

## 四、总结

本规范确立了 LMJCore 框架下数据存储与关系索引的协作范式。通过将**指针生成**与**关系维护**解耦，LMJCore 在保持嵌入式内核高性能与简洁性的同时，为上层构建丰富多样的查询模式提供了无限的可能性。
注意:上述文档使用的指针*未使用标准定义*仅使用简易抽象进行展示