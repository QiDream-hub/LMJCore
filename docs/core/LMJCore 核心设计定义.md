# LMJCore 核心设计定义

> **当前时间：2025年10月13日**

---

## 一、基本理念

**LMJCore** 是一个基于 [LMDB](https://symas.com/lmdb/) 的嵌入式数据存储内核。

其核心设计哲学是：**通过指针将复杂嵌套数据结构扁平化存储，实现极致性能与灵活性**。  
本文件为 LMJCore 内核与上层应用之间交互的数据格式与规则的**权威定义**，确保系统语义清晰、行为可预测。

---

## 二、指针系统（核心定义）

### 2.1 指针结构

指针是一个 **17 字节** 的固定长度二进制数据结构，由两部分构成：

| 组成部分 | 数据类型 | 长度 | 说明 |
|----------|----------|------|------|
| 类型前缀 | `uint8_t` (枚举) | 1 字节 | 标识实体类型 |
| 唯一编号 | `uint8_t[16]` | 16 字节 | 128 位全局唯一标识符 |

> ✅ 总长度：17 字节（紧凑、高效、适合内存映射）

---

### 2.2 类型枚举

```c
enum lmjcore_entity_type {
    LMJCORE_OBJ = 0x01,  // 普通对象
    LMJCORE_ARR = 0x02   // 数组
};
```

---

### 2.3 指针暴露策略

| 使用场景 | 推荐格式 | 说明 |
|---------|----------|------|
| 内核交互 | 17 字节二进制格式 | 默认格式，性能最优 |
| 日志/调试 | 可读字符串格式（如 `obj_01a2b3c4...`） | 通过工具函数转换 |

> 🔧 **工具支持**：内核提供双向转换函数（二进制 ↔ 字符串），供上层按需使用。  
> 🔄 **上层自由选择**：开发者可根据性能或可读性需求自行决定使用哪种格式。

---

## 三、数据存储映射（LMJCore → LMDB）

### 3.1 `main` 数据库

| 属性 | 说明 |
|------|------|
| **职责** | 存储所有单一映射（对象成员的值） |
| **Key 构成** | `<对象指针 (17字节)> + <成员名称 (变长字节序列)>` |
| **Value** | 二进制安全字节数组（Binary-safe Bytestring） |
| **Value 内容** | - 原始数据的二进制表示（整数、浮点、字符串等）<br>- 其他实体的 17 字节指针 |
| **成员名称编码** | 由上层决定（如 UTF-8 或二进制哈希），内核视为不透明序列 |
| **语义解释** | 值的具体类型和结构由上层应用解析，内核不感知 |

> 🔐 **安全性**：Key 总长度受 LMDB 默认 511 字节限制 → 成员名最大允许 **493 字节**

> ⚠️ **错误码**：若成员名超出长度限制，返回 `LMJCORE_ERR_MEMBER_TOO_LONG`

---

### 3.2 `arr` 数据库

| 属性 | 说明 |
|------|------|
| **职责** | 存储所有列表映射（数组元素、对象成员列表） |
| **Key** | `<列表实体指针 (17字节)>`<br>（可以是数组指针或对象指针） |
| **Value** | 二进制安全字节数组，表示列表中的元素 |
| **元素内容** | 原始值或 17 字节指针 |
| **重复 Key** | 允许（用于数组元素或成员列表） |
| **存储顺序** | 按插入顺序排列（FIFO） |
| **随机访问** | 不支持下标随机访问或排序功能 |

> 📌 **排序建议**：如需有序访问（如下标或时间），上层应在 Value 中编码排序信息（如前 4 字节为下标），并在读取后自行排序。

---

## 四、数据存在性与完整性规则

### 4.1 对象/数组存在性判定

| 状态 | 判定条件 |
|------|----------|
| 有效对象/数组 | 指针在 `arr` 数据库中存在对应条目 |
| 无效指针 | 在 `arr` 中无对应条目 → 不指向任何有效实体 |
| 空对象/空数组 | 指针存在，但对应值列表为空（无成员/元素） |

> ✅ 此规则为系统基础语义，上层同步策略可在此基础上增强或覆盖。

---

### 4.2 成员值完整性规则

#### 成员定义
- 成员被定义当且仅当其名称记录在该对象指针对应的 `arr` 成员列表中。

#### 值状态
- **已赋值**：`main` 数据库中存在对应值。
- **缺失值 (Missing Value)**：`main` 中不存在对应值 → **合法中间状态**

> ✅ “缺失值”常见于“分步初始化”场景，系统允许此状态。

#### 读取语义

| 模式 | 行为 | 返回值 |
|------|------|--------|
| 宽松模式 | 自动补全缺失值 | 完整结构，缺失部分填充为 `null`（成员）或 `[]`（数组） |
| 严格模式 | 遇到缺失立即终止 | 返回 `null`，附带错误信息 |

---

### 4.3 幽灵成员（Ghost Member）

- **定义**：在 `main` 中存在键值对，但其成员名称未在 `arr` 中注册。
- **性质**：属于**严重数据损坏**，正常访问路径无法发现。
- **成因**：写事务原子性被破坏（极罕见）。
- **检测机制**：通过专用审计函数 `lmjcore_audit_object()` 检测。
- **处理建议**：
  1. 立即停止写入；
  2. 执行修复；
  3. 使用 `lmjcore_repair_object`（事务性修复函数）恢复一致性。

> 🔥 **警报级别**：最高级别数据完整性警报。

> ✅ **关键保证**：在正常写事务流程下，**不可能产生幽灵成员**。

---

### 4.4 数据访问模式

| 模式 | 行为 | 适用场景 |
|------|------|----------|
| **宽松模式 (Loose Mode)** | 自动补全缺失数据，保证查询完成 | 普通业务、内容展示、配置读取 |
| **严格模式 (Strict Mode)** | 遇到任何缺失立即终止查询 | 金融系统、数据校验、测试环境 |

> 📝 两种模式均返回包含详细错误信息的统一结构，便于诊断。

---

### 4.5 成员名称长度限制

- `main` 库 Key = `17 字节指针 + 成员名`
- 受 LMDB 默认 Key 上限 511 字节限制
- → 成员名最大允许 **493 字节**

> ⚠️ **前置检查**：在 `put` 操作前会校验成员名长度，超限返回 `LMJCORE_ERR_MEMBER_TOO_LONG`

---

### 4.6 统一返回结构体内存归属

- 所有返回 `{data, errors}` 的 API 接口，均写入**调用方提供的缓冲区**。
- 内核**不执行堆分配**，避免跨层内存管理歧义。
- 生命周期由调用方控制，提升性能与安全性。

---

### 4.7 根指针持久化格式

- 工具函数统一输出 **34 字符小写 HEX 字符串**（无分隔符）
- 示例：`f1e2d3c4b5a69788796a5b4c3d2e1f0a`
- 配置文件可直接以文本形式保存，无需二进制处理。

---

## 五、设计优势总结

| 优势 | 说明 |
|------|------|
| **极致性能** | 固定长度指针、二进制优先交互、扁平化存储设计 |
| **灵活通用** | 成员名支持任意字节序列；指针格式可自由转换；适应多种上层需求 |
| **完整性保障** | 明确的存在性规则、缺失值语义、幽灵成员检测机制，确保数据安全 |
| **可扩展性强** | 通过指针轻松构建任意复杂嵌套结构，支持未来扩展 |

---

✅ **文档状态**：已整理完毕  
📅 **最后更新时间**：2025年10月13日