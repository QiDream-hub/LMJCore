# LMJCore 概念指南

_——用指针把嵌套数据“摊平”的高性能存储内核_

---

## 一、为什么需要 LMJCore？

现代应用常需处理高度动态、深度嵌套的数据（如 JSON、配置树、图结构）。传统数据库要么强制模式（如关系型），要么在读写性能上妥协（如文档数据库解析开销大）。

**LMJCore 的答案是**：

> **不提供查询，只专注极致高效的存储** —— 把复杂结构“拆开存”，用**全局指针**重新“拼起来”。

它不是完整数据库，而是一个**可嵌入的存储内核**，为上层查询引擎（如未来的 `LMJQuery`）提供坚实、快速、一致的数据基石。

---

## 二、核心思想：三句话讲清 LMJCore

1. **万物皆指针**  
    所有对象和数组都有一个 **17 字节的全局唯一 ID**（首字节标识类型：`0x01`=对象，`0x02`=数组）。这个指针就是它们在系统中的“身份证”。
    
2. **数据被彻底扁平化**  
    嵌套结构（如 `{user: {name: "Alice"}}`）不会以树形存储，而是被**拆成独立片段**，分散在两个物理空间中。
    
3. **靠两个“仓库”协作**
    - **`arr`（集合袋区）**：回答“这个实体有哪些关联项？”（如对象的成员名列表、数组的元素列表）
    - **`main`（命名格子区）**：回答“这个成员的具体值是多少？”（如 `name → "Alice"`）

通过指针 + 两个仓库，既能高效点查，又能灵活组合任意复杂结构。

---

## 三、存储模型：两个空间，一套规则

### ▶ 空间 1：`arr` —— “集合袋”

- **作用**：记录一个实体“拥有什么”。
- **特点**：
    - Key = 实体指针（17B）
    - Value = 成员名 或 数组元素（可多个，自动去重排序）
    - 对象用它存**成员名列表**；数组用它存**元素列表**

> ✨ 比喻：`arr` 就像一个贴了标签的布袋，你往里扔“name”、“age”这些纸条，袋子会自动整理好。

### ▶ 空间 2：`main` —— “命名格子”

- **作用**：存储具体值。
- **特点**：
    - Key = `[实体指针][成员名]`（如 `obj_abc:name`）
    - Value = 二进制原始数据 **或另一个指针**
    - 每个成员独占一个“格子”，点查 O(1)

> ✨ 比喻：`main` 是一排带双标签的抽屉（“谁的 + 叫什么”），拉开就能拿到内容。

### ▶ 嵌套？靠指针链接！

```json
{
  "user": { "name": "Bob" },
  "tags": ["a", "b"]
}
```

存储时：

- `main[parent_ptr + "user"]` → `child_obj_ptr`（17B 指针）
- `main[parent_ptr + "tags"]` → `tags_arr_ptr`（17B 指针）
- 子对象/数组各自在 `arr`/`main` 中定义

→ 整棵树被“拍扁”，但可通过指针完整重建。

---

## 四、关键设计原则

|原则|说明|
|---|---|
|**指针化引用**|所有复杂关系通过指针连接，避免冗余复制|
|**二元归一**|仅两种基础结构：**对象**（键值对容器）和 **数组**（有序/无序元素集合）|
|**扁平化存储**|利用 LMDB 的排序与遍历优势，将嵌套转为高效 KV|

---

## 五、一致性如何保障？

LMJCore 在灵活性与安全性之间取得平衡：

- ✅ **允许“缺失值”**：成员已在 `arr` 注册，但 `main` 中暂无值 → 合法中间状态（如分步初始化）
- ❌ **禁止“幽灵成员”**：`main` 中有值，但 `arr` 中未注册 → 视为**严重数据损坏**
    - 提供审计函数 `lmjcore_audit_object()` 主动检测
    - 正常写事务下**不可能出现**（原子性保证）

> 💡 这种设计让上层既可动态增删字段（无模式），又能在异常时快速发现并修复问题。

---

## 六、为什么这样设计？优势在哪？

|优势|说明|
|---|---|
|**极致读性能**|成员可并发点查 `main`，无需递归解析嵌套|
|**局部更新**|修改一个字段只需更新一个 `main` 格子，不影响父结构|
|**继承 LMDB 优势**|ACID 事务、零拷贝、内存映射、崩溃安全|
|**真正无类型**|Value 是纯二进制，上层可自由编码（JSON、Protobuf、自定义）|
|**无限可扩展**|通过指针轻松构建图、树、双向引用等复杂拓扑|

---

## 七、给开发者的建议

- **顺序不是内核的事**：`arr` 不保插入序。若需有序数组，请在 Value 中编码下标（如前 4 字节）。
- **成员名 ≤ 493 字节**：受 LMDB Key 长度限制（17B 指针 + 成员名 ≤ 511B）。
- **指针生成需唯一**：内核不校验唯一性，冲突会导致数据覆盖。
- **扩展类型请用成员名**：不要改指针首字节！可通过 `_type` 成员实现应用层类型系统。

---

## 八、总结

LMJCore 的本质是：

> **用最简模型（对象 + 数组 + 指针），在 LMDB 之上构建一个高性能、强一致、无模式的存储内核。**

它不做查询，但为查询铺平道路；它不解释类型，但为类型留足空间。  
如果你需要一个**可嵌入、低延迟、高可靠**的底层存储引擎，LMJCore 提供了一个优雅而强大的选择。

---

> 🔗 延伸阅读
> 
> - [LMJCore 核心设计定义]（规范细节）
> - [LMJCore 框架扩展：指针关系管理规范]
> - [LMJCore 事务模型]
