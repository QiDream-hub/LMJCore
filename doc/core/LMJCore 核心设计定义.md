# LMJCore 核心设计定义

> **当前时间：2025年10月13日**

---

## 一、基本理念

**LMJCore** 是一个基于 [LMDB](https://symas.com/lmdb/) 的嵌入式数据存储内核。

其核心设计哲学是：**通过指针将复杂嵌套数据结构扁平化存储，实现极致性能与灵活性**。  
本文件为 LMJCore 内核与上层应用之间交互的数据格式与规则的**权威定义**，确保系统语义清晰、行为可预测。

---

## **二、指针系统（核心定义）**

### 2.1 指针结构规范

**LMJCore 默认指针实现**为 **17 字节** 固定长度二进制结构：

| 组成部分 | 长度    | 规范约束                               |
| ---- | ----- | ---------------------------------- |
| 类型前缀 | 1 字节  | **必须** 为 `lmjcore_entity_type` 枚举值 |
| 唯一编号 | 16 字节 | 128 位全局唯一标识符                       |

> ⚠️ **规范约束**：无论是否使用自定义指针生成器，**指针的首字节语义由 LMJCore 内核保留**，用于标识实体基础类型。
> 
> 🔧 **扩展建议**：二次开发如需要扩展指针语义，**请通过占用成员名空间实现**，不得覆盖或重新定义首字节的类型语义。

---

### 2.2 类型枚举（保留语义）

```c
enum lmjcore_entity_type {
    LMJCORE_OBJ = 0x01,  // 普通对象
    LMJCORE_ARR = 0x02   // 数组
};
```

> 🚫 **语义保留**：此枚举定义的实体类型语义由 LMJCore 内核保留，**不得重新定义或扩展**。

---

### 2.3 指针生成器接口规范

```c
typedef int (*lmjcore_ptr_generator_fn)(void *ctx, uint8_t out[LMJCORE_PTR_LEN]);
```

**规范约束**：
- 输出缓冲区长度由 `LMJCORE_PTR_LEN` 编译时宏定义
- **`out[0]` 必须** 设置为有效的 `lmjcore_entity_type` 枚举值
- 生成器负责填充剩余 `LMJCORE_PTR_LEN - 1` 字节的语义
- 应保证指针在实例范围内的唯一性

---

## 三、数据存储映射（LMJCore → LMDB）

### 3.1 `main` 数据库

| 属性 | 说明 |
|------|------|
| **职责** | 存储所有单一映射（对象成员的值） |
| **Key 构成** | `<对象指针 (17字节)> + <成员名称 (变长字节序列)>` |
| **Value** | 二进制安全字节数组（Binary-safe Bytestring） |
| **Value 内容** | - 原始数据的二进制表示（整数、浮点、字符串等）<br>- 其他实体的 17 字节指针 |
| **成员名称编码** | 由上层决定（如 UTF-8 或二进制哈希），内核视为不透明序列 |
| **语义解释** | 值的具体类型和结构由上层应用解析，内核不感知 |

> 🔐 **安全性**：Key 总长度受 LMDB 默认 511 字节限制 → 成员名最大允许 **493 字节**

> ⚠️ **错误码**：若成员名超出长度限制，返回 `LMJCORE_ERR_MEMBER_TOO_LONG`

---

### 3.2 `arr` 数据库

| 属性 | 说明 |
|------|------|
| **职责** | 存储所有列表映射（数组元素、对象成员列表） |
| **Key** | `<列表实体指针 (17字节)>`<br>（可以是数组指针或对象指针） |
| **Value** | 二进制安全字节数组，表示列表中的元素 |
| **元素内容** | 原始值或 17 字节指针 |
| **重复 Key** | 允许（用于数组元素或成员列表） |
| **存储顺序** | 按插入顺序排列（FIFO） |
| **随机访问** | 不支持下标随机访问或排序功能 |

> 📌 **排序建议**：如需有序访问（如下标或时间），上层应在 Value 中编码排序信息（如前 4 字节为下标），并在读取后自行排序。

---

## 四、数据存在性与完整性规则

### 4.1 对象/数组存在性判定

| 状态 | 判定条件 |
|------|----------|
| 有效对象/数组 | 指针在 `arr` 数据库中存在对应条目 |
| 无效指针 | 在 `arr` 中无对应条目 → 不指向任何有效实体 |
| 空对象/空数组 | 指针存在，但对应值列表为空（无成员/元素） |

> ✅ 此规则为系统基础语义，上层同步策略可在此基础上增强或覆盖。

---

### 4.2 成员值完整性规则

#### 成员定义
- 成员被定义当且仅当其名称记录在该对象指针对应的 `arr` 成员列表中。

#### 值状态
- **已赋值**：`main` 数据库中存在对应值。
- **缺失值 (Missing Value)**：`main` 中不存在对应值 → **合法中间状态**

> ✅ “缺失值”常见于“分步初始化”场景，系统允许此状态。

#### 读取语义

| 模式 | 行为 | 返回值 |
|------|------|--------|
| 宽松模式 | 自动补全缺失值 | 完整结构，缺失部分填充为 `null`（成员）或 `[]`（数组） |
| 严格模式 | 遇到缺失立即终止 | 返回 `null`，附带错误信息 |

---

### 4.3 幽灵成员（Ghost Member）

- **定义**：在 `main` 中存在键值对，但其成员名称未在 `arr` 中注册。
- **性质**：属于**严重数据损坏**，正常访问路径无法发现。
- **成因**：写事务原子性被破坏（极罕见）。
- **检测机制**：通过专用审计函数 `lmjcore_audit_object()` 检测。
- **处理建议**：
  1. 立即停止写入；
  2. 执行修复；
  3. 使用 `lmjcore_repair_object`（事务性修复函数）恢复一致性。

> 🔥 **警报级别**：最高级别数据完整性警报。

> ✅ **关键保证**：在正常写事务流程下，**不可能产生幽灵成员**。

---

### 4.4 数据访问模式

| 模式 | 行为 | 适用场景 |
|------|------|----------|
| **宽松模式 (Loose Mode)** | 自动补全缺失数据，保证查询完成 | 普通业务、内容展示、配置读取 |
| **严格模式 (Strict Mode)** | 遇到任何缺失立即终止查询 | 金融系统、数据校验、测试环境 |

> 📝 两种模式均返回包含详细错误信息的统一结构，便于诊断。

---

### 4.5 成员名称长度限制

- `main` 库 Key = `17 字节指针 + 成员名`
- 受 LMDB 默认 Key 上限 511 字节限制
- → 成员名最大允许 **493 字节**

> ⚠️ **前置检查**：在 `put` 操作前会校验成员名长度，超限返回 `LMJCORE_ERR_MEMBER_TOO_LONG`

---

### 4.6 统一返回结构体内存归属

- 所有返回 `{data, errors}` 的 API 接口，均写入**调用方提供的缓冲区**。
- 内核**不执行堆分配**，避免跨层内存管理歧义。
- 生命周期由调用方控制，提升性能与安全性。

---

### 4.7 根指针持久化格式

- 工具函数统一输出 **34 字符小写 HEX 字符串**（无分隔符）
- 示例：`f1e2d3c4b5a69788796a5b4c3d2e1f0a`
- 配置文件可直接以文本形式保存，无需二进制处理。

---

## 五、设计优势总结

| 优势 | 说明 |
|------|------|
| **极致性能** | 固定长度指针、二进制优先交互、扁平化存储设计 |
| **灵活通用** | 成员名支持任意字节序列；指针格式可自由转换；适应多种上层需求 |
| **完整性保障** | 明确的存在性规则、缺失值语义、幽灵成员检测机制，确保数据安全 |
| **可扩展性强** | 通过指针轻松构建任意复杂嵌套结构，支持未来扩展 |

---

### **六、扩展与兼容性规范**

#### 6.1 指针扩展约束

**首要原则**：保持与默认实现的语义兼容性。

| 扩展方式 | 合规性 | 说明 |
|----------|--------|------|
| 增加指针长度 | ✅ 允许 | 通过 `LMJCORE_PTR_LEN` 宏定义 |
| 重新定义首字节语义 | 🚫 **禁止** | 首字节为 LMJCore 保留语义 |
| 扩展实体类型枚举 | 🚫 **禁止** | 使用成员名空间进行类型扩展 |
| 自定义指针生成逻辑 | ✅ 允许 | 必须遵守首字节约束 |

#### 6.2 类型扩展规范

**正确做法**：通过成员名空间实现类型扩展

```c
// ✅ 合规：通过成员名扩展类型系统
// 在 "type" 成员中定义扩展类型
lmjcore_set_member(obj_ptr, "type", "user_defined_type");
lmjcore_set_member(obj_ptr, "subtype", "advanced_feature");

// 🚫 禁止：重新定义指针首字节
// 不得将 LMJCORE_OBJ(0x01) 重新解释为其他语义
```

#### 6.3 多实例支持规范

**合规扩展示例**：
```c
// 允许：在保留首字节前提下扩展指针
// 指针结构：[1字节类型][1字节实例ID][15字节UUID]
uint8_t custom_ptr[LMJCORE_PTR_LEN];
custom_ptr[0] = LMJCORE_OBJ;  // 遵守规范
custom_ptr[1] = instance_id;  // 扩展语义
// ... 剩余字节自定义
```

#### 6.4 存储兼容性警告

> ⚠️ **重要**：使用自定义指针长度创建的数据库，**与默认实现不兼容**。
> 
> 不同指针配置的数据库实例应使用**独立的存储路径**，避免数据混淆。

---

### **七、实施建议**

#### 7.1 对新应用的指导

如需扩展数据类型或语义，建议采用以下合规方式：

1. **使用标准成员名**：通过 `_type`、`_class`、`_kind` 等成员存储扩展类型信息
2. **分层设计**：在 LMJCore 基础对象之上构建应用层类型系统
3. **工具函数封装**：提供应用层工具函数简化扩展类型的使用

#### 7.2 对系统集成者的提醒

- 不同指针配置的 LMJCore 实例应视为**不同系统组件**
- 在系统文档中明确记录使用的指针配置
- 提供迁移工具用于不同指针格式间的数据转换

✅ **文档状态**：已整理完毕  
📅 **最后更新时间**：2025年11月14日