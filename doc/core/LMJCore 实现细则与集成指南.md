# LMJCore 实现细则与集成指南

当前时间：2025年10月13日

## 一、指针生成机制

### 1. 内核职责与默认提供

- 内核核心职责**不负责生成指针**。内核仅验证传入指针的格式合法性（17字节，首字节为有效实体类型）。
- 指针的全局唯一性与生成逻辑**完全由上层应用保证**。

### 可插拔接口

- 内核定义函数指针类型：

  ```c
   typedef int (*lmjcore_ptr_generator)(void *ctx, uint8_t out[17]);
   ```

- 上层可在初始化时传入自定义实现（如 ULID、雪花算法等），实现灵活扩展。

### 2. 自增ID注意事项

若上层选择自增 ID 作为指针生成策略：

- 必须自行解决**分布式环境下的 ID 分配与冲突问题**，内核不提供协调机制。
- 生成的16字节编号部分应按**大端序（Big-endian）填充**，以确保在 LMDB 中按键排序时保持数字顺序一致性。

> ⚠️ 风险提示：重复指针将导致“后写者胜”覆盖行为，可能引发数据丢失或逻辑混乱。

## 二、成员名称的编码与存储

### 1. 内核视角

- 内核将成员名称视为**二进制安全的字节数组（Binary-safe Bytestring）**。
- 不进行任何编码假设或转换 —— 可为 UTF-8 字符串、ASCII、哈希值甚至任意二进制数据。
- 成员名称长度受 LMDB Key 最大长度限制（通常约 511 字节），扣除 17 字节对象指针后，实际可用空间约为 494 字节。

### 2. 上层建议

- ✅ 推荐使用 UTF-8 编码字符串，以保证可读性与通用兼容性。
- ❌ 避免使用过长名称，防止触及 LMDB 键长上限。
- 若需高性能索引，可考虑使用固定长度哈希（如 SHA-1 截断）作为成员名。

## 三、值的序列化与解释

- 所有值（Value）均作为**二进制安全字节数组**存储，完全对齐 LMDB 原生语义。
- 内核**不关心也不干预**值的内容结构 —— 无论是整数、浮点、JSON 还是嵌套对象指针。
- 值的解释权完全由上层应用掌控。
- 上层需统一采用一致的序列化协议，例如：
    - MessagePack
    - JSON Binary Format
    - Protocol Buffers
    - 自定义二进制格式

> 🔧 提示：建议在系统层面约定统一的序列化标准，并通过工具函数封装编解码逻辑。

## 四、跨事务的指针可见性与缓存一致性

- LMJCore 完全继承并映射 LMDB 的 MVCC（多版本并发控制）语义。
    - 在一个写事务中新创建的指针，在提交成功后，对所有之后开启的只读事务立即可见。
    - 已开启的只读事务（在写事务提交前启动）无法看到新数据，其视图为事务开始时的快照。

### 缓存处理建议

若上层应用自行缓存了指针或实体数据，必须遵循以下原则：

- 在事务边界刷新本地缓存。
- 监听写事务提交事件以触发失效。
- 避免长期持有跨事务的数据引用。

✅ 推荐实践：结合 `lmjcore_entity_exist()` 探针函数验证缓存有效性。

## 五、数据审计与修复工具

### 1. 审计函数 `lmjcore_audit_object`

- **功能**：检查指定对象指针的数据完整性，重点检测“幽灵成员”。
- **输出**：返回详细审计报告结构，包含：
    - 对象指针整体状态（完整 / 有缺失值 / 有幽灵成员）
    - 错误列表，每项包括：
        - 违规键的完整二进制 Key（`<对象指针><成员名>`）
        - 错误类型（如 `LMJCORE_AUDIT_ERR_GHOST_MEMBER`）

> 🔧 工具支持：提供辅助函数将二进制 Key 转换为可读 HEX 格式。

### 2. 修复函数 `lmjcore_repair_object`

- **功能**：尝试修复审计发现的问题。
    - 针对“幽灵成员”：安全删除其在 `main` 数据库中的键值对。
    - **不会重新注册为合法成员** —— 此操作需由上层显式完成（因无法判断原始意图）。
- **输入**：对象指针、成员名列表（用于上下文判断）
- **输出**：修复报告，列出已删除的幽灵成员键。
- **事务保证**：修复操作在独立写事务中执行，具备原子性。成功则全部生效；失败则自动回滚，数据库状态不变。
- **并发限制**：修复期间阻塞其他写事务（遵循 LMDB 单写原则）。已开启的只读事务不受影响。

## 六、错误码定义与继承规范

### 1. 错误码继承原则

- LMJCore 作为 LMDB 的语义化封装层，**完全透传原生 LMDB 错误码**，便于底层异常定位。

### 2. 错误码空间划分

|组件层级|错误码范围|说明|
|---|---|---|
|LMDB 原生错误|-30799 ~ -30779|LMDB 内核定义的标准错误码，直接透传|
|LMJCore 内核错误|-32000 ~ -32999|LMJCore 特有的语义化错误码|
|未来扩展层错误|-33000 ~ -33999|为查询层、网络层等预留|
|用户自定义错误|-34000 ~ -34999|供应用层业务逻辑使用|

### 3. 核心错误码示例

```c
#define LMJCORE_SUCCESS 0
#define LMJCORE_ERROR_INVALID_PARAM -32000            // 参数无效
#define LMJCORE_ERROR_MEMBER_TOO_LONG -32002          // 成员名长度超限
#define LMJCORE_ERROR_INVALID_POINTER -32003          // 指针格式错误
#define LMJCORE_ERROR_BUFFER_TOO_SMALL -32004         // 输出缓冲区空间不足
#define LMJCORE_ERROR_MEMORY_ALLOCATION_FAILED -32005 // 内存分配失败
#define LMJCORE_ERROR_ENTITY_NOT_FOUND -32006         // 实体不存在
#define LMJCORE_ERROR_MEMBER_NOT_FOUND -32007         // 成员不存在败
```

### 4. 错误处理建议

- **LMDB 错误**：检查事务状态、磁盘空间、文件权限等系统级问题。
- **LMJCore 错误**：验证输入参数、检查数据完整性规则是否被破坏。
- **分层诊断**：通过错误码范围快速定位问题所属层级（底层存储 vs 语义层 vs 业务层）。

✅ 优势：全局唯一、可追溯、利于自动化监控与告警。

## 七、官方支持的“分步初始化”模式

- LMJCore 提供 `lmjcore_obj_member_register` API，允许在 `arr` 数据库中预先注册成员名，而无需立即赋值。
- 此机制支持以下高级模式：
    - 结构先行（Schema-first）
    - 延迟赋值（Lazy Initialization）
    - 分阶段构建复杂对象

### 使用说明

- 注册后，该成员处于“缺失值”状态，属于合法中间态。
- 后续可通过 `lmjcore_obj_member_put` 补充具体值。
- 开发者应确保最终完成赋值，以维持业务逻辑完整性。

✅ 场景示例：用户注册流程中先创建账户结构，后续异步填充头像、地址等非关键字段。