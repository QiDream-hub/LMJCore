# LMJCore 框架扩展：指针关系管理规范

当前时间：2025年10月13日

---

## 一、核心原则：职责分离

LMJCore 作为存储内核，严格遵循“存、取、管”的基础定位。在指针与对象的关系管理上，系统采用清晰的**职责分离**架构：

- **LMJCore 内核层**  
  负责安全地创建数据实体（对象/数组），生成全局唯一指针，并确保其原子性写入与存在性注册（通过 `arr` 数据库条目）。不参与任何业务语义层面的关系维护。

- **上层应用 / 查询层**  
  接收由内核返回的指针后，根据具体业务需求，主动将该指针注册到相应的**关系索引结构**中。此类操作通常与实体创建置于同一事务中，以保证逻辑一致性。

> ✅ 核心理念：**存储归内核，索引归上层** —— 实现解耦、灵活与可扩展性的统一。

---

## 二、运作机制

### 2.1 指针生成与返回

当调用 `lmjcore_create_object()` 或 `lmjcore_create_array()` 等接口时：
- 内核使用配置的指针生成器（默认 UUIDv4）生成一个 17 字节的全局唯一指针。
- 在 `main` 和 `arr` 数据库中完成必要的初始化写入（如空成员列表）。
- 将新实体的指针作为结果返回给调用方。

示例返回值（字符串格式）：`obj_746573746f626a5f31`

---

### 2.2 关系注册（非强制，按需实现）

高层应用在获取新指针后，应立即执行以下步骤（建议在同一事务中）：

1. **分类注册**  
   将指针添加至类型集合中，便于后续全量扫描或批量处理。  
   示例：向 `arr_all_users` 数组追加新用户指针。

2. **命名索引建立**  
   构建名称到指针的映射，支持快速查找。  
   示例：在 `main` 库中设置键 `user_index:john_doe` → 值为 `obj_user_john` 的二进制指针。

3. **标签化组织**  
   将指针加入特定标签对应的数组，实现多维分组。  
   示例：向 `arr_tag_vip` 中插入该用户的指针。

📌 所有上述结构均由上层自行设计和维护，LMJCore 不提供内置支持。

---

### 2.3 查询路径

所有基于语义的查询必须遵循以下标准流程：

1. **从索引出发**  
   使用预建的关系结构定位目标指针。  
   例如：读取 `user_index:john_doe` 获取其对象指针。

2. **凭指针访问数据**  
   使用获得的指针直接访问 `main` 和 `arr` 数据库，读取实际内容。

3. **避免全库扫描**  
   ❌ 不推荐遍历所有实体进行条件匹配，因性能随数据增长急剧下降。

✅ 正确模式：`索引查询 → 指针获取 → 直接点查`

---

### 2.4 指针生成器接口（可插拔）

上层可自定义指针生成策略，接口定义如下：

```c
typedef int (*lmjcore_ptr_generator_fn)(void *ctx, uint8_t out[17]);
```

| 策略类型   | 特点             | 是否默认  |
| ------ | -------------- | ----- |
| UUIDv4 | 全局唯一，无需协调，不可读  | 可选    |
| ULID   | 时间有序，全局唯一，利于调试 | 可选    |
| 自增 ID  | 长度短，可读性强，需防冲突  | 需外部保障 |

⚠️ **重要警告**：内核不对指针唯一性做二次校验。若发生冲突，后写者将覆盖前者，导致数据丢失。使用非随机策略时，开发者须确保全局唯一性。

---

### 2.5 exist 探针函数

用于检查指针是否指向一个有效的数据实体。

#### 函数签名
```c
int lmjcore_exist(lmjcore_txn txn, lmjcore_ptr ptr);
```

#### 返回值语义

| 返回值 | 含义 |
|-------|------|
| `1`   | 指针有效：在 `arr` 数据库中存在对应条目，表示该指针指向一个已创建的对象或数组。 |
| `0`   | 指针无效：在 `arr` 中无记录，不指向任何实体。 |
| `< 0` | 操作失败：如事务错误、LMDB IO 异常等，具体错误码参考 `LMJCORE_ERR_*` 定义。 |

#### 典型用途
- 创建前校验指针唯一性（强一致性场景）
- 动态引用验证（如反向链接、外键检查）
- 缓存失效判断

---

## 三、架构优势

| 优势          | 说明                                       |
| ----------- | ---------------------------------------- |
| **内核纯净**    | LMJCore 保持极简，不含任何业务索引逻辑，易于维护与升级。         |
| **极致灵活**    | 上层可自由构建任意索引模型：关系型、图状、倒排、Trie 树等，不受内核限制。  |
| **明确边界**    | 开发者清楚知道“数据如何存储”由内核负责，“数据如何查找”由自己掌控，责任清晰。 |
| **支持多引擎共享** | 多个独立查询系统可基于同一份原始数据构建各自索引，实现异构查询共存。       |
| **便于测试与模拟** | 可轻松替换指针生成器或模拟索引行为，提升单元测试覆盖率。             |

---

## 四、总结

本规范确立了 LMJCore 框架下**数据存储**与**关系索引**的标准协作范式。

通过将指针生成与关系维护彻底解耦，LMJCore 在维持嵌入式内核高性能、低延迟、高一致性的基础上，为上层系统提供了构建多样化查询能力的无限可能性。

该设计完美契合“计算与存储分离”的现代架构趋势，是实现灵活、可扩展、高可用数据系统的理想基石。

> 📝 注意：本文档中使用的指针示例仅为抽象表达，实际交互应使用标准 17 字节二进制格式或经工具转换的 HEX 字符串格式。

✅ 文档状态：已整理完毕  
📅 最后更新时间：2025年10月13日